\section{Description and Methodology}

This report describes three distinct systems; Each one more more power efficient than the last.

The first implementation is a simple polling-based approach. The second one uses interrupts, removing time needlessly used for idling. The final system goes into a deep sleep mode, waking only when coerced to do so by an interrupt from the GPIO controller.

Energy consumption was noted for each improvement to the system, and one can clearly see how power consumption is reduced by multiple orders of magnitude in the final system.

\subsection{A program without interrupts}

The first system implements a simple polling-based mechanism for updating the LEDs on the game pad. The main loop simply loads whatever values are found on the game pad (GPIO port C, pins 0-7), shifts them to the appropriate position required by the output port (GPIO port A, pins 8 - 15), and sets the corresponding pins to logical low.

\subsection{A program with interrupts}

The second system contains a simple, yet important architectural change. The system no longer blindly loads register values each tick, instead updating only when receiving interrupts from GPIO port C.

A number of flags are set to allow for interrupt-driven event handling, which are described in the following code segment \ref{lstinputlisting:interrupt-flags}.

Highlights include allowing for interrupt generation and -acceptance on GPIO port C, edge-driven interrupts on both hi-lo and lo-hi transitions from the gamepad, as well as enabling both odd and even interrupts.

\lstinputlisting[linerange={113-125}]{../code/ex1.s}
\label{lstinputlisting:interrupt-flags}

Callback handlers are registered for both odd and even pins. These allow us to handle the interrupts generated by the gamepad buttons.

\lstinputlisting[linerange={33-33, 43-43}]{../code/ex1.s}
\label{lstinputlisting:interrupt-handlers}

The interrupt handler is defined as folows \ref{lstinputlisting:interrupt-handler}.

First order of the day is clearing any potential lingering interrupts. This to avoid the interrupt handler being interrupted by another interrupt, hindering anything productive from being done.
Gamepad output is then loaded from GPIO port C, stored, bitshifted to match the output pins on port A, and written to the registry.

Interrupts are available for both edge transitions on the gamepad, with the attached handler executing on both events.
This ensured that the LEDs are updated on both button presses and releases. It contrasts with the earlier polling approach, where the values were blindly copied on each tick, irregardles of the values changed or not.


\lstinputlisting[linerange={151-156, 162-170}]{../code/ex1.s}
\label{lstinputlisting:interrupt-handler}

\subsection{A program using low energy modes}

\subsection{Further improvements}
The program described in this report sleeps when it is idle, just waiting for an interrupt.
This is done in the interest of power efficiency.
%add label instead of elsewhere
As described earlier, the program sleeps in what is called EM3, where some of the functions are running.
However, a fourth energy mode is available in the micro controller, and even more power could be saved.

The fourth stage, EM4, is a deep sleep mode where only a few services use power.
After going to EM4, it would take 160 $\mu$s to go back to EM0.
This would be satisfactory for the intended behavior of the program, and not present much perceived lag when pressing a button.
Unfortunately, to wake up the unit again is limited.
Either the micro controller needs to be reset, or GPIO interrupt wake must be enabled.
The interrupts for waking up the unit needs to be sent to one of a list of GPIO ports.\cite{referencemanual}

With these limitations, it is clear that the deep sleep mode will not be usable within the requirements and with the provided hardware.
A small change to the hardware would let the program work as intended, and sleep deeper.
With a multiplexer of all the signals from the buttons, and output to one of the supported GPIO ports, it would be easy to support EM4.
